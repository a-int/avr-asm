.include "m32def.inc"
.org 0
	jmp reset ; вектор прерывания по сброрсу
	jmp int_0 ; вектор прерывания по внешнему входу INT0
	jmp int_1 ; вектор прерывания по внешнему входу INT1
	jmp int_2 ; вектор прерывания по внешнему входу INT2
	jmp timer2_comp ; вектор прерывания по совпадению T/C2
	jmp timer2_ovf ; вектор прерывания по переполнению T/C2
	jmp timer1_capt ; вектор прерывания по захвату T/C1
	jmp timer1_compa ; вектор прерывания по совпадению T/C1A
	jmp timer1_compb ; вектор прерывания по совпадению T/C1B
	jmp timer1_ovf ; вектор прерывания по переполнению T/C2
	jmp timer0_comp ; вектор прерывания по совпадению T/C0
	jmp timer0_ovf ; вектор прерывания по переполнению T/C2
	jmp spi_cts ; вектор прерывания по окончанию обмена SPI
	jmp usart_rxc ; вектор прерывания по окончанию приема USART
	jmp usart_udre ; вектор прерывания когда UDR передатчика ...
	jmp usart_txc ; вектор прерывания по окончании передачи USART
	jmp a_d_c ; вектор прерывания по окончании преобразовании АЦП
	jmp ee_rdy ; вектор прерывания по готовности EEPROM
	jmp ana_comp ; вектор прерывания от аналогового компаратора
	jmp t_w_i ; вектор прерывания по окончании обмена TWI
	jmp spm_rdy ; вектор прерывания по готовности SPM

; ПОДПРОГРАММА ИНИЦИАЛИЗАЦИИ
reset:
	cli; флаг i=0 все прерывания запрещены
	
	ldi r16, 0x04 ; задаем Stack Pointer size High 
	out SPH, r16
	ldi r16, 0x5f; задаем Stack Pointer size Low
	out SPL, r16

main:
	clr r18
	lds r17, $460 ; чтение константы для преобразования
	lds r16, $461 ; чтение константы для преобразования
	clr r24
	ldi r23, 0x64
	rcall mul3x2
	;rcall bcd ; вызов подпрограммы перевода
	sts $463, r21 ; сохранение старшего байта результата
	sts $464,r20 ; сохранение младшего байта результата

	rjmp main

bcd:
	mov r0, r16
	clr r20
	clr r21

	ldi r19, 0x08 ; n bits
	ldi r17, 0x03
	ldi r18, 0x30
	

edin:
	mov r16, r20
	andi r16, 0x0f
	cpi r16, 0x05
	brcs des
	add r20, r17
des:
	mov r16, r20
	andi r16, 0xf0
	cpi r16, 0x50
	brcs sot
	add r20, r18
sot:
	mov r16, r21
	andi r16, 0x0f
	cpi r16, 0x05
	brcs shift
	add r21, r17
shift:
	rol r0
	rol r20
	rol r21

	dec r19
	brne edin
	ret

mul3x2:
	clr r0 			; очистка регистра р0 для сохранения результата
	clr r1 			; очистка регистра р1 для сохранения результата
	clr r2			; очистка регистра р2 для сохранения результата
	clr r3			; очистка регистра р3 для сохранения результата 
	clr r4			; очистка регистра р4 для сохранения результата

	clr r21			; очистка доп регистра для сдвига множимого
	clr r22			; очистка доп регистра для сдвига множимого
	ldi r16, 0x10		; сохранения колличества битов в множителе
n1:				
	lsr r24			; сдвиг старшего байта множителя вправо
	ror r23			; цикличиский свдиг младшего байта множимого вправо
	brcc sdv		; если бит в флаге С = 0 то пропуск
	add r0, r18		; прибавление младшего байта множимого
	adc r1, r19		; прибавление второго байта множимого
	adc r2, r20		; прибавление третьего байта множимого
	adc r3, r21		; прибавление четвертого байта множимого
	adc r4, r22		; прибавление пятого байта множимого
sdv:
	lsl r18			; сдиви младшего байта множимого влево
	rol r19			; сдвиг второго байта множимого влево
	rol r20			; сдвиг третьего байта множимого влево
	rol r21			; сдвиг четвертого байта множимого влево
	rol r22			; сдвиг пятого байта множимого влево
	dec r16			; уменьшение оставшегося кол-ва битов в множителе
	brne n1			; если остались биты переход в начало цикла

	ret

int_0:
int_1:
int_2:
timer2_comp:
timer2_ovf:
timer1_capt:
timer1_compa:
timer1_compb:
timer1_ovf:
timer0_comp:
timer0_ovf:
spi_cts:
usart_rxc:
usart_udre:
usart_txc:
a_d_c:
ee_rdy:
ana_comp:
t_w_i:
spm_rdy: reti
